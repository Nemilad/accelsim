{
  "Micro fusion": "; example of micro fusion\n\tinc\t\t[addr1]\t\t\t; read-modify micro fusion\n\tpush\t\teax\t\t\t; address-write micro fusion\n\tor\t\t[addr2], 1\t\t; two types of micro fusion",
  "Macro fusion": "; example of macro fusion\nm1:\tinc\t\teax\t\t\t\n\tjz\t\tm1\t\t\t; macro fusion\n\tadd\t\tebx, 5\n\tjne\t\tm1\t\t\t; second macro fusion\n\tsub\t\tebx, 2\n\tjc\t\tm1\t\t\t; trird macro fusion\n\tpush\t\t[addr1]\n\tand\t\t[addr2], ebx\n\tjnp\t\tm1\t\t\t; macro fusion with memory operand\n\tand\t\teax, ebx\n\tjnp\t\tm1\t\t\t; macro fusion without memory operand\n\tinc\t\tebx\n\tinc\t\tebx\t\t\t; instruction that can be fused get to the last decoder",
  "LSD": "; example of Loop Stream Detecton\nm1:\txor\t\teax, eax\n\tadd\t\teax, 5\nm2:\tdec\t\tebx\n\tpush\t\teax\n\tloop\t\tm2\t\t; folded cycle\n\tpush\t\t[addr1]\t\n\tloop\t\tm1\t\t; main cycle",
  "Zeroing idioms": "; example of zeroing idioms\n\txor\t\teax, eax\t\t; zeroing with xor\n\tsub\t\trax, rax\t\t; zeroing with sub",
  "Move elimination": "; example of move elimination\n\tmov\t\teax, ebx\t\t; move elimination with 32bit registers\n\tmov\t\trax, rbx\t\t; move elimination with 64bit registers\n\tmov\t\teax, eax\t\t; move elimination with registor move to itself",
  "print1_32.asm": "; Equivalent C code\n; /* printf1.c  print an int and an expression */\n; #include \n; int main()\n; {\n;   int a=5;\n;   printf(\"a=%d, eax=%d\\n\", a, a+2);\n;   return 0;\n; }\n\n; Declare some external functions\n;\n;       extern\tprintf\t\t; the C function, to be called (not inplemented in the simulator)\n\n;       SECTION .data\t\t; Data section, initialized variables (not inplemented in the simulator)\n\n;\ta:\tdd\t5\t\t; int a=5; (not inplemented in the simulator)\n;fmt:   db \"a=%d, eax=%d\", 10, 0 \t; The printf format, \"\\n\",'0' (not inplemented in the simulator)\n\n\n;       SECTION .text                   ; Code section. (not inplemented in the simulator)\n\n;       global main\t\t; the standard gcc entry point (not inplemented in the simulator)\n;main:\t\t\t\t; the program label for the entry point (not inplemented in the simulator)\n        push\t\tebp\t\t; set up stack frame\n        mov\t\tebp, esp\n\n\tmov\t\teax, [a]\t; put a from store into register\n\tadd\t\teax, 2\t\t; a+2\n\tpush\t\teax\t\t; value of a+2\n        push\t\t[a]\t\t; value of variable a\n        push\t\t[fmt]\t\t; address of ctrl string\n;       call\t\tprintf\t\t; Call C function (not inplemented in the simulator)\n        add\t\tesp, 12\t\t; pop stack 3 push times 4 bytes\n\n        mov\t\tesp, ebp\t; takedown stack frame\n        pop\t\tebp\t\t; same as \"leave\" op\n\n\tmov\t\teax, 0\t\t;  normal, no error, return value\n;\tret\t\t\t\t; return (not inplemented in the simulator)",
  "print1_64.asm": "; Equivalent C code\n; /* printf1.c  print a long int, 64-bit, and an expression */\n; #include <stdio.h>\n; int main()\n; {\n;   long int a=5;\n;   printf(\"a=%ld, rax=%ld\\n\", a, a+2);\n;   return 0;\n; }\n\n; Declare external function\n;\textern\tprintf\t\t\t; the C function, to be called (not inplemented in the simulator)\n\n;\tSECTION .data\t\t\t; Data section, initialized variables (not inplemented in the simulator)\n\n;\ta:\tdq\t5\t\t; long int a=5; (not inplemented in the simulator)\n;fmt:\tdb \"a=%ld, rax=%ld\", 10, 0\t; The printf format, \"\\n\",'0' (not inplemented in the simulator)\n\n\n;\tSECTION .text\t\t\t; Code section. (not inplemented in the simulator)\n\n;\tglobal main\t\t\t; the standard gcc entry point (not inplemented in the simulator)\n;main:\t\t\t\t\t; the program label for the entry point (not inplemented in the simulator)\n\tpush\t\trbp\t\t; set up stack frame\n\t\n\tmov\t\trax, [a]\t; put \"a\" from store into register\n\tadd\t\trax, 2\t\t; a+2  add constant 2\n\tmov\t\trdi, fmt\t; format for printf\n\tmov\t\trsi, [a]\t; first parameter for printf\n\tmov\t\trdx, rax\t; second parameter for printf\n\tmov\t\trax, 0\t\t; no xmm registers\n;\tcall    \tprintf\t\t; Call C function (not inplemented in the simulator)\n\n\tpop\t\trbp\t\t; restore stack\n\n\tmov\t\trax,0\t\t; normal, no error, return value\n;\tret\t\t\t\t; return (not inplemented in the simulator)",
  "factorial.asm": "; ----------------------------------------------------------------------------\n; factorial.asm\n;\n; Illustration of a recursive function.\n; ----------------------------------------------------------------------------\t\n\n;\tglobal _factorial\t\t; (not inplemented in the simulator)\n\t\n;\tsection .text\t\t\t; (not inplemented in the simulator)\n;_factorial:\t\t\t\t; (not inplemented in the simulator)\n        mov     eax, [esp+4]\t\t; n\n\tcmp\teax, 1\t\t\t; n <= 1\n        jnle\tL1\t\t\t; if not, go do a recursive call\n        mov\teax, 1\t\t\t; otherwise return 1\n\tjmp\tL2\nL1:\n\tdec\teax\t\t\t; n-1\n\tpush\teax\t\t\t; push argument\n;\tcall\t_factorial\t\t; do the call, result goes in eax (not inplemented in the simulator)\n\tadd\tesp, 4\t\t\t; get rid of argument\n\timul\teax, [esp+4]\t\t; n * factorial(n-1)\nL2:\n;\tret\t\t\t\t; return (not inplemented in the simulator)",
  "Variant 1": "L1:\n\tmov\tbx, ax\n\tmov\tecx, ebx\n\tor\t[addr1], 16\n\tpush\t[addr2]\n\tadd\tdx, bx\n\tjne\tL4\n\tinc\teax\n\tjz\tL1\n\tsub\tdx, [addr3]\n\tjc\th4\nL2:\n\tpop\t[addr2]\n\tnot\tebx\n\tand\tax, [addr3]\n\tloop\tL2\n\txor\trax, rax\n\tmov\tecx, [addr4]\nL3:\n\tmov\tebx, ebx\n\tmov\trax, 5\n\tmov\trcx, rax\n\txor\t[addr2], ebx\n\tsbb\tax, [addr3]\n\tjc\tL1\nL4:\n\tcmp\t[addr2], ecx\n\tjc\tL3\n\tsub\tebx, ebx\n\tsub\tax, ax\n\ttest\trdx, rax\n\tmov\tdx, [addr2]\n\tand\teax, ebx\n\tmov\teax, [addr3]",
  "Variant 2": "M1:\n\tmov\tecx, ebx\n\tpush\trax\n\tnot\t[addr1]\n\txor\trbx, rax\n\tinc\tdx\n\tje\tM2\n\ttest\tax, cx\n\tja\tM3\nM2:\n\tadd\trax, 5\n\tjle\tM1\n\tmov\teax, 2\n\tand\t[addr2], ax\nM3:\n\tmov\tecx, ecx\n\tmov\trcx, rax\n\tcmp\trax, rbx\n\tinc\tebx\n\tje\tM1\n\tcmp\teax, ebx\n\tjnbe\tM3\nM4:\n\tsub\trax, rdx\n\tjs\tM3\n\tor\t[addr4], rax\n\tneg\tdx\n\tloop\tM4\n\tinc\t[addr3]\n\tjng\tM1\n\tsub\tebx, ebx\n\txor\tax, ax\n\tmov\tcx, ax\n\txor\trbx, rbx",
  "Variant 3": "R1:\n\tor\t[addr1], 2\n\tadc\t[addr1], 3\n\tmov\trbx, eax\n\tadd\tax, cx\n\tloop\tR1\n\tadd\tcx, bx\n\tmov\trdx, [addr2]\nR2:\n\txor\trcx, rcx\n\tmov\teax, ebx\n\tmov\trcx, rax\n\tmov\tbx, cx\nR3:\n\tsub\teax, eax\n\tmov\teax, 9\n\tor\trcx, bx\n\tje\tR4\n\tsub\tbx, 2\nR4:\n\tcmp\tedx, ebx\n\tjna\tR1\n\tdec\tdx\n\tje\tR3\n\tdec\trcx\n\tjng\tR2\n\txor\tcx, cx\n\tmov\tecx, ecx\n\tdec\t[addr3]\n\tjz\tR4\n\tinc\tebx\n\tpop\t[addr3]\n\tmov\trax, [addr1]\n\tpush\teax",
  "Variant 4": "K1:\n\tmov\trbx, rbx\n\txor\tebx, ebx\nK2:\n\tmov\trcx, rdx\n\txor\tcx, cx\n\tmov\teax, ebx\nK3:\n\tadd\trbx, [addr1]\n\tjle\tK4\n\tsub\tdx, ax\n\tjc\tK3\n\tinc\tebx\n\tjnz\tK1\n\tsub\trdx, rdx\n\txor\tedx, [addr1]\n\tpush\tax\n\tdec\t[addr2]\n\tje\tK3\n\tmov\tbx, dx\nK4:\n\tmov\tebx, 6\n\tsbb\t[addr2], rcx\n\tmov\teax, 15\n\tnot\t[addr3]\n\ttest\teax, ecx\n\tloop\tK4\n\tpush\t[addr3]\n\tsbb\trax, rdx\n\tjbe\tK4\n\tadd\trdx, 6\n\tdec\tax\n\tjz\tK3\n\tsub\trax, 16",
  "Variant 5": "R1:\n\tsub\trax, rax\n\tjb\tR4\n\ttest\trcx, rax\n\tjnle\tR2\n\tcmp\trax, rcx\n\tjz\tR1\n\tmov\trbx, rax\nR2:\n\tadd\trcx, bx\n\tcmp\tbx, 5\n\tjno\tR1\n\tloop\tR2\n\tmov\tdx, ax\n\tdec\t[addr1]\n\tjnz\tR2\n\tmov\tecx, eax\nR3:\n\tmov\tebx, ebx\n\tmov\trdx, 11\n\tsbb\trdx, [addr1]\n\tjb\tR2\n\tsub\tax, ax\n\txor\teax, eax\nR4:\n\tmov\trcx, 3\n\tadd\tebx, 14\n\tjc\tR1\n\tand\tebx, eax\n\tsbb\trbx, rcx\n\tmov\trax, [addr1]\n\tinc\tebx\n\tjs\tR4\n\txor\tecx, ecx",
  "Variant 6": "L1:\n\tadd\tdx, 23\n\tmov\trax, [addr1]\n\tinc\tebx\n\tjnae\tL2\n\tsub\trax, 3\n\tloop\tL1\n\txor\trax, rax\n\tmov\trbx, rax\n\tpush\trbx\n\txor\trax, rax\n\tmov\teax, eax\nL2:\n\tmov\teax, edx\n\tmov\trbx, 4\n\tpop\trbx\n\tadc\tebx, [addr2]\n\tand\trdx, [addr2]\n\tjnbe\tL1\n\tcmp\tax, 1\n\tjnb\tL3\n\tsub\trdx, 7\n\tjz\tL1\nL3:\n\tmov\trbx, rax\n\tsub\t[addr3], eax\n\tjnb\tL4\n\tsub\tecx, ecx\nL4:\n\tsub\tax, ax\n\tjbe\tL1\n\tmov\tbx, ax\n\tor\tbx, cx\n\tpush\tbx",
  "Variant 7": "M1:\n\tmov\tecx, ecx\n\tmov\trax, rbx\n\tnot\teax\n\tand\t[addr1], ax\n\tjna\tM1\n\tmov\teax, ecx\nM2:\n\tmov\tdx, [addr2]\n\tadd\t[addr3], dx\n\tjz\tM4\n\tmov\teax, [addr1]\n\tor\teax, ebx\n\tloop\tM2\nM3:\n\txor\tecx, ecx\n\tmov\tax, cx\n\tpop\t[addr2]\n\tdec\tax\n\tinc\tebx\n\tjnz\tM4\n\tand\tdx, ax\n\tjnp\tM3\n\tsub\trax, [addr3]\n\tja\tM1\nM4:\n\txor\tcx, cx\n\tmov\tecx, 8\n\tsub\trbx, rbx\n\ttest\tax, 1\n\tjc\tM4\n\tdec\tax\n\tjnc\tM3\n\tsub\trax, rax",
  "Variant 8": "K1:\n\txor\trbx, rbx\n\tmov\tebx, ebx\nK2:\n\tmov\tebx, ecx\n\tmov\trax, rcx\n\tpush\t1\n\tnot\t[addr1]\n\tand\tax, [addr1]\n\tjna\tK4\n\tinc\tdx\n\tjl\tK1\n\tsub\tax, ax\n\tjnz\tK4\nK3:\n\tmov\tdx, [addr2]\n\tsbb\trax, rdx\n\tmov\trbx, 3\n\tsub\tcx, cx\n\txor\trbx, rax\n\tsub\teax, eax\n\tmov\tax, bx\nK4:\n\tsub\t[addr2], ebx\n\tjnb\tK2\n\tnot\tax\n\tmov\tax, dx\n\tloop\tK4\n\tpush\tax\n\tadd\tbx, cx\n\tjo\tK4\n\tmov\tax, [addr1]\n\tmov\trcx, [addr3]\n\tor\trcx, bx",
  "Variant 9": "R1:\n\tadd\trax, 5\n\tjno\tR4\n\tnot\t[addr1]\n\tinc\t[addr2]\n\tjl\tR3\n\tsub\tedx, 32\n\tloop\tR1\nR2:\n\txor\trax, rax\n\tsub\tdx, ax\n\tjnc\tR1\n\tinc\tebx\n\tjng\tR3\n\ttest\teax, ecx\n\tjp\tR4\n\txor\tbx, bx\nR3:\n\tmov\trbx, rcx\n\tsub\teax, eax\n\tmov\tecx, 12\nR4:\n\tmov\teax, eax\n\tdec\trbx\n\tand\tebx, ecx\n\tmov\tcx, ax\n\txor\tedx, [addr3]\n\tpush\tax\n\tdec\tdx\n\tje\tR1\n\tmov\teax, ecx\n\tdec\trax\n\tjg\tR4\n\tsbb\t[addr2], ecx",
  "Variant 10": "M1:\n\txor\trax, rax\n\tsub\teax, eax\t\n\tmov\trcx, rbx\n\tneg\trdx\n\tmov\tecx, ebx\nM2:\n\ttest\tcx, ax\n\tjne\tM3\n\tadd\tebx, [addr1]\n\tjna\tM1\n\tinc\tbx\n\tjnl\tM2\nM3:\n\tmov\trax, [addr2]\n\tinc\tebx\n\tjnae\tM1\n\tdec\teax\n\tloop\tM3\n\tmov\teax, ebx\n\tsub\tecx, ecx\n\tmov\trax, 8\nM4:\n\tmov\tbx, ax\n\txor\t[addr2], ebx\n\tsbb\tax, [addr3]\n\tjc\tM4\n\tsub\tax, ax\n\tcmp\t[addr3], bx\n\tjnb\tM3\n\tdec\trbx\n\tjz\tM4\n\tsub\trcx, rax\n\tor\trax, [addr1]"
}