{
  "micro fusion": "; example of micro fusion\n\tinc\t\t[addr1]\t\t\t; read-modify micro fusion\n\tpush\t\teax\t\t\t; address-write micro fusion\n\tor\t\t[addr2], 1\t\t; two types of micro fusion",
  "macro fusion": "; example of macro fusion\nm1:\tinc\t\teax\t\t\t\n\tjz\t\tm1\t\t\t; macro fusion\n\tadd\t\tebx, 5\n\tjne\t\tm1\t\t\t; second macro fusion\n\tsub\t\tebx, 2\n\tjc\t\tm1\t\t\t; trird macro fusion\n\tpush\t\t[addr1]\n\tand\t\t[addr2], ebx\n\tjnp\t\tm1\t\t\t; macro fusion with memory operand\n\tand\t\teax, ebx\n\tjnp\t\tm1\t\t\t; macro fusion without memory operand\n\tinc\t\tebx\n\tinc\t\tebx\t\t\t; instruction that can be fused get to the last decoder",
  "LSD": "; example of Loop Stream Detecton\nm1:\txor\t\teax, eax\n\tadd\t\teax, 5\nm2:\tdec\t\tebx\n\tpush\t\teax\n\tloop\t\tm2\t\t; folded cycle\n\tpush\t\t[addr1]\t\n\tloop\t\tm1\t\t; main cycle",
  "zeroing idioms": "; example of zeroing idioms\n\txor\t\teax, eax\t\t; zeroing with xor\n\tsub\t\trax, rax\t\t; zeroing with sub",
  "move elimination": "; example of move elimination\n\tmov\t\teax, ebx\t\t; move elimination with 32bit registers\n\tmov\t\trax, rbx\t\t; move elimination with 64bit registers\n\tmov\t\teax, eax\t\t; move elimination with registor move to itself",
  "print1_32.asm": "; Equivalent C code\n; /* printf1.c  print an int and an expression */\n; #include \n; int main()\n; {\n;   int a=5;\n;   printf(\"a=%d, eax=%d\\n\", a, a+2);\n;   return 0;\n; }\n\n; Declare some external functions\n;\n;       extern\tprintf\t\t; the C function, to be called (not inplemented in the simulator)\n\n;       SECTION .data\t\t; Data section, initialized variables (not inplemented in the simulator)\n\n;\ta:\tdd\t5\t\t; int a=5; (not inplemented in the simulator)\n;fmt:   db \"a=%d, eax=%d\", 10, 0 \t; The printf format, \"\\n\",'0' (not inplemented in the simulator)\n\n\n;       SECTION .text                   ; Code section. (not inplemented in the simulator)\n\n;       global main\t\t; the standard gcc entry point (not inplemented in the simulator)\n;main:\t\t\t\t; the program label for the entry point (not inplemented in the simulator)\n        push\t\tebp\t\t; set up stack frame\n        mov\t\tebp, esp\n\n\tmov\t\teax, [a]\t; put a from store into register\n\tadd\t\teax, 2\t\t; a+2\n\tpush\t\teax\t\t; value of a+2\n        push\t\t[a]\t\t; value of variable a\n        push\t\t[fmt]\t\t; address of ctrl string\n;       call\t\tprintf\t\t; Call C function (not inplemented in the simulator)\n        add\t\tesp, 12\t\t; pop stack 3 push times 4 bytes\n\n        mov\t\tesp, ebp\t; takedown stack frame\n        pop\t\tebp\t\t; same as \"leave\" op\n\n\tmov\t\teax, 0\t\t;  normal, no error, return value\n;\tret\t\t\t\t; return (not inplemented in the simulator)",
  "print1_64.asm": "; Equivalent C code\n; /* printf1.c  print a long int, 64-bit, and an expression */\n; #include <stdio.h>\n; int main()\n; {\n;   long int a=5;\n;   printf(\"a=%ld, rax=%ld\\n\", a, a+2);\n;   return 0;\n; }\n\n; Declare external function\n;\textern\tprintf\t\t\t; the C function, to be called (not inplemented in the simulator)\n\n;\tSECTION .data\t\t\t; Data section, initialized variables (not inplemented in the simulator)\n\n;\ta:\tdq\t5\t\t; long int a=5; (not inplemented in the simulator)\n;fmt:\tdb \"a=%ld, rax=%ld\", 10, 0\t; The printf format, \"\\n\",'0' (not inplemented in the simulator)\n\n\n;\tSECTION .text\t\t\t; Code section. (not inplemented in the simulator)\n\n;\tglobal main\t\t\t; the standard gcc entry point (not inplemented in the simulator)\n;main:\t\t\t\t\t; the program label for the entry point (not inplemented in the simulator)\n\tpush\t\trbp\t\t; set up stack frame\n\t\n\tmov\t\trax, [a]\t; put \"a\" from store into register\n\tadd\t\trax, 2\t\t; a+2  add constant 2\n\tmov\t\trdi, fmt\t; format for printf\n\tmov\t\trsi, [a]\t; first parameter for printf\n\tmov\t\trdx, rax\t; second parameter for printf\n\tmov\t\trax, 0\t\t; no xmm registers\n;\tcall    \tprintf\t\t; Call C function (not inplemented in the simulator)\n\n\tpop\t\trbp\t\t; restore stack\n\n\tmov\t\trax,0\t\t; normal, no error, return value\n;\tret\t\t\t\t; return (not inplemented in the simulator)",
  "factorial.asm": "; ----------------------------------------------------------------------------\n; factorial.asm\n;\n; Illustration of a recursive function.\n; ----------------------------------------------------------------------------\t\n\n;\tglobal _factorial\t\t; (not inplemented in the simulator)\n\t\n;\tsection .text\t\t\t; (not inplemented in the simulator)\n;_factorial:\t\t\t\t; (not inplemented in the simulator)\n        mov     eax, [esp+4]\t\t; n\n\tcmp\teax, 1\t\t\t; n <= 1\n        jnle\tL1\t\t\t; if not, go do a recursive call\n        mov\teax, 1\t\t\t; otherwise return 1\n\tjmp\tL2\nL1:\n\tdec\teax\t\t\t; n-1\n\tpush\teax\t\t\t; push argument\n;\tcall\t_factorial\t\t; do the call, result goes in eax (not inplemented in the simulator)\n\tadd\tesp, 4\t\t\t; get rid of argument\n\timul\teax, [esp+4]\t\t; n * factorial(n-1)\nL2:\n;\tret\t\t\t\t; return (not inplemented in the simulator)"
}