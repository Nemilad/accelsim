{
  "микро слияние": "; пример работы микро слияния\n\tinc\t\t[addr1]\t\t\t; микро слияние read-modify \n\tpush\t\teax\t\t\t; микро слияние address-write\n\tor\t\t[addr2], 1\t\t; микро слияние двух типов одновременно",
  "макро слияние": "; пример работы макро слияния\nm1:\tinc\t\teax\t\t\t\n\tjz\t\tm1\t\t\t; макро слияние\n\tadd\t\tebx, 5\n\tjne\t\tm1\t\t\t; второе макро слияние\n\tsub\t\tebx, 2\n\tjc\t\tm1\t\t\t; третье макро слияние\n\tpush\t\t[addr1]\n\tand\t\t[addr2], ebx\n\tjnp\t\tm1\t\t\t; потенциальное макро слияние с операндом памяти\n\tand\t\teax, ebx\n\tjnp\t\tm1\t\t\t; потенциальное макро слияние без операнда памяти\n\tinc\t\tebx\n\tinc\t\tebx\t\t\t; инструкция которая может быть использована в слиянии попадает на последний декодер",
  "LSD": "; пример работы Loop Stream Detecton\nm1:\txor\t\teax, eax\n\tadd\t\teax, 5\nm2:\tdec\t\tebx\n\tpush\t\teax\n\tloop\t\tm2\t\t; вложенный цикл\n\tpush\t\t[addr1]\t\n\tloop\t\tm1\t\t; основной цикл",
  "нуль идиомы": "; пример работы нуль идиом\n\txor\t\teax, eax\t\t; нуль идиома с инструкцией xor\n\tsub\t\trax, rax\t\t; нуль идиома с инструкцией sub",
  "move elimination": "; пример работы move elimination\n\tmov\t\teax, ebx\t\t; move elimination c регистром 32бит\n\tmov\t\trax, rbx\t\t; move elimination c регистром 64бит\n\tmov\t\teax, eax\t\t; move elimination с перемещением регистра в себя",
  "print1_32.asm": "; Эквивалентный код на C\n; /* printf1.c  выводит int и результат сложения */\n; #include \n; int main()\n; {\n;   int a=5;\n;   printf(\"a=%d, eax=%d\\n\", a, a+2);\n;   return 0;\n; }\n\n; Объявление внутренних функций\n;\n;       extern\tprintf\t\t; вызов C функции (не поддерживается симулятором)\n\n;       SECTION .data\t\t; Data section, initialized variables (не поддерживается симулятором)\n\n;\ta:\tdd\t5\t\t; int a=5; (не поддерживается симулятором)\n;fmt:   db \"a=%d, eax=%d\", 10, 0 \t; The printf format, \"\\n\",'0' (не поддерживается симулятором)\n\n\n;       SECTION .text                   ; Code section. (не поддерживается симулятором)\n\n;       global main\t\t; the standard gcc entry point (не поддерживается симулятором)\n;main:\t\t\t\t; the program label for the entry point (не поддерживается симулятором)\n        push\t\tebp\t\t; set up stack frame\n        mov\t\tebp, esp\n\n\tmov\t\teax, [a]\t; put a from store into register\n\tadd\t\teax, 2\t\t; a+2\n\tpush\t\teax\t\t; value of a+2\n        push\t\t[a]\t\t; value of variable a\n        push\t\t[fmt]\t\t; address of ctrl string\n;       call\t\tprintf\t\t; Call C function (не поддерживается симулятором)\n        add\t\tesp, 12\t\t; pop stack 3 push times 4 bytes\n\n        mov\t\tesp, ebp\t; takedown stack frame\n        pop\t\tebp\t\t; same as \"leave\" op\n\n\tmov\t\teax, 0\t\t;  normal, no error, return value\n;\tret\t\t\t\t; return (не поддерживается симулятором)",
  "print1_64.asm": "; Эквивалентный код на C\n; /* printf1.c  выводит long int, 64-bit, и результат сложения */\n; #include <stdio.h>\n; int main()\n; {\n;   long int a=5;\n;   printf(\"a=%ld, rax=%ld\\n\", a, a+2);\n;   return 0;\n; }\n\n; Declare external function\n;\textern\tprintf\t\t\t; the C function, to be called (не поддерживается симулятором)\n\n;\tSECTION .data\t\t\t; Data section, инициализация переменных (не поддерживается симулятором)\n\n;\ta:\tdq\t5\t\t; long int a=5; (не поддерживается симулятором)\n;fmt:\tdb \"a=%ld, rax=%ld\", 10, 0\t; The printf format, \"\\n\",'0' (не поддерживается симулятором)\n\n\n;\tSECTION .text\t\t\t; Code section. (не поддерживается симулятором)\n\n;\tglobal main\t\t\t; the standard gcc entry point (не поддерживается симулятором)\n;main:\t\t\t\t\t; the program label for the entry point (не поддерживается симулятором)\n\tpush\t\trbp\t\t; set up stack frame\n\t\n\tmov\t\trax, [a]\t; put \"a\" from store into register\n\tadd\t\trax, 2\t\t; a+2  add constant 2\n\tmov\t\trdi, fmt\t; format for printf\n\tmov\t\trsi, [a]\t; first parameter for printf\n\tmov\t\trdx, rax\t; second parameter for printf\n\tmov\t\trax, 0\t\t; no xmm registers\n;\tcall    \tprintf\t\t; Call C function (не поддерживается симулятором)\n\n\tpop\t\trbp\t\t; restore stack\n\n\tmov\t\trax,0\t\t; normal, no error, return value\n;\tret\t\t\t\t; return (не поддерживается симулятором)",
  "factorial.asm": "; ----------------------------------------------------------------------------\n; factorial.asm\n;\n; Иллюстрация работы рекурсивной функции.\n; ----------------------------------------------------------------------------\t\n\n;\tglobal _factorial\t\t; (не поддерживается симулятором)\n\t\n;\tsection .text\t\t\t; (не поддерживается симулятором)\n;_factorial:\t\t\t\t; (не поддерживается симулятором)\n        mov     eax, [esp+4]\t\t; n\n\tcmp\teax, 1\t\t\t; n <= 1\n        jnle\tL1\t\t\t; if not, go do a recursive call\n        mov\teax, 1\t\t\t; otherwise return 1\n\tjmp\tL2\nL1:\n\tdec\teax\t\t\t; n-1\n\tpush\teax\t\t\t; push argument\n;\tcall\t_factorial\t\t; do the call, result goes in eax (не поддерживается симулятором)\n\tadd\tesp, 4\t\t\t; get rid of argument\n\timul\teax, [esp+4]\t\t; n * factorial(n-1)\nL2:\n;\tret\t\t\t\t; return (не поддерживается симулятором)",
  "Вариант 1": "L1:\n\tmov\tbx, ax\n\tmov\tecx, ebx\n\tor\t[addr1], 16\n\tpush\t[addr2]\n\tadd\tdx, bx\n\tjne\tL4\n\tinc\teax\n\tjz\tL1\n\tsub\tdx, [addr3]\n\tjc\th4\nL2:\n\tpop\t[addr2]\n\tnot\tebx\n\tand\tax, [addr3]\n\tloop\tL2\n\txor\trax, rax\n\tmov\tecx, [addr4]\nL3:\n\tmov\tebx, ebx\n\tmov\trax, 5\n\tmov\trcx, rax\n\txor\t[addr2], ebx\n\tsbb\tax, [addr3]\n\tjc\tL1\nL4:\n\tcmp\t[addr2], ecx\n\tjc\tL3\n\tsub\tebx, ebx\n\tsub\tax, ax\n\ttest\trdx, rax\n\tmov\tdx, [addr2]\n\tand\teax, ebx\n\tmov\teax, [addr3]",
  "Вариант 2": "M1:\n\tmov\tecx, ebx\n\tpush\trax\n\tnot\t[addr1]\n\txor\trbx, rax\n\tinc\tdx\n\tje\tM2\n\ttest\tax, cx\n\tja\tM3\nM2:\n\tadd\trax, 5\n\tjle\tM1\n\tmov\teax, 2\n\tand\t[addr2], ax\nM3:\n\tmov\tecx, ecx\n\tmov\trcx, rax\n\tcmp\trax, rbx\n\tinc\tebx\n\tje\tM1\n\tcmp\teax, ebx\n\tjnbe\tM3\nM4:\n\tsub\trax, rdx\n\tjs\tM3\n\tor\t[addr4], rax\n\tneg\tdx\n\tloop\tM4\n\tinc\t[addr3]\n\tjng\tM1\n\tsub\tebx, ebx\n\txor\tax, ax\n\tmov\tcx, ax\n\txor\trbx, rbx",
  "Вариант 3": "R1:\n\tor\t[addr1], 2\n\tadc\t[addr1], 3\n\tmov\trbx, eax\n\tadd\tax, cx\n\tloop\tR1\n\tadd\tcx, bx\n\tmov\trdx, [addr2]\nR2:\n\txor\trcx, rcx\n\tmov\teax, ebx\n\tmov\trcx, rax\n\tmov\tbx, cx\nR3:\n\tsub\teax, eax\n\tmov\teax, 9\n\tor\trcx, bx\n\tje\tR4\n\tsub\tbx, 2\nR4:\n\tcmp\tedx, ebx\n\tjna\tR1\n\tdec\tdx\n\tje\tR3\n\tdec\trcx\n\tjng\tR2\n\txor\tcx, cx\n\tmov\tecx, ecx\n\tdec\t[addr3]\n\tjz\tR4\n\tinc\tebx\n\tpop\t[addr3]\n\tmov\trax, [addr1]\n\tpush\teax",
  "Вариант 4": "K1:\n\tmov\trbx, rbx\n\txor\tebx, ebx\nK2:\n\tmov\trcx, rdx\n\txor\tcx, cx\n\tmov\teax, ebx\nK3:\n\tadd\trbx, [addr1]\n\tjle\tK4\n\tsub\tdx, ax\n\tjc\tK3\n\tinc\tebx\n\tjnz\tK1\n\tsub\trdx, rdx\n\txor\tedx, [addr1]\n\tpush\tax\n\tdec\t[addr2]\n\tje\tK3\n\tmov\tbx, dx\nK4:\n\tmov\tebx, 6\n\tsbb\t[addr2], rcx\n\tmov\teax, 15\n\tnot\t[addr3]\n\ttest\teax, ecx\n\tloop\tK4\n\tpush\t[addr3]\n\tsbb\trax, rdx\n\tjbe\tK4\n\tadd\trdx, 6\n\tdec\tax\n\tjz\tK3\n\tsub\trax, 16",
  "Вариант 5": "R1:\n\tsub\trax, rax\n\tjb\tR4\n\ttest\trcx, rax\n\tjnle\tR2\n\tcmp\trax, rcx\n\tjz\tR1\n\tmov\trbx, rax\nR2:\n\tadd\trcx, bx\n\tcmp\tbx, 5\n\tjno\tR1\n\tloop\tR2\n\tmov\tdx, ax\n\tdec\t[addr1]\n\tjnz\tR2\n\tmov\tecx, eax\nR3:\n\tmov\tebx, ebx\n\tmov\trdx, 11\n\tsbb\trdx, [addr1]\n\tjb\tR2\n\tsub\tax, ax\n\txor\teax, eax\nR4:\n\tmov\trcx, 3\n\tadd\tebx, 14\n\tjc\tR1\n\tand\tebx, eax\n\tsbb\trbx, rcx\n\tmov\trax, [addr1]\n\tinc\tebx\n\tjs\tR4\n\txor\tecx, ecx",
  "Вариант 6": "",
  "Вариант 7": "",
  "Вариант 8": "",
  "Вариант 9": "",
  "Вариант 10": ""
}